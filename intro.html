<!DOCTYPE html>
<html>
<head>
  <title>Docs</title>
  <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ" crossorigin="anonymous"> 
  <style>


    
 body {
      background-color: #f2f2f2; /* Grey background color */
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }

    .popup-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    .popup {
      background-color: #ff9dbd; /* Pink background color */
      padding: 100px;
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
      
      
    }

    .circles {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100vh;
  overflow: hidden;
  z-index: -1;
}

.circles li {
  position: absolute;
  display: block;
  list-style: none;
  width: 20px;
  /* border-radius: 50%!important; */
  height: 20px;
  background: pink;
  animation: animate 25s linear infinite;
  bottom: -150px;
}

.circles li:nth-child(1) {
  left: 5%;
  width: 50px;
  height: 50px;
  animation-delay: 0s;
}

.circles li:nth-child(2) {
  left: 10%;
  width: 20px;
  height: 20px;
  animation-delay: 2s;
  animation-duration: 12s;
}

.circles li:nth-child(3) {
  left: 6%;
  width: 20px;
  height: 20px;
  animation-delay: 4s;
}

.circles li:nth-child(4) {
  left: 89%;
  width: 60px;
  height: 60px;
  animation-delay: 0s;
  animation-duration: 18s;
}

.circles li:nth-child(5) {
  left: 90%;
  width: 20px;
  height: 20px;
  animation-delay: 0s;
}

.circles li:nth-child(6) {
  left: 85%;
  width: 10px;
  height: 10px;
  animation-delay: 3s;
}

.circles li:nth-child(7) {
  left: 5%;
  width: 50px;
  height: 50px;
  animation-delay: 7s;
}

.circles li:nth-child(8) {
  left: 10%;
  width: 25px;
  height: 25px;
  animation-delay: 15s;
  animation-duration: 45s;
}

.circles li:nth-child(9) {
  left: 100%;
  width: 15px;
  height: 15px;
  animation-delay: 2s;
  animation-duration: 35s;
}

.circles li:nth-child(10) {
  left: 95%;
  width: 50px;
  height: 50px;
  animation-delay: 0s;
  animation-duration: 11s;
}

@keyframes animate {
  0% {
    transform: translateY(0) rotate(0deg);
    opacity: 0.8;
    border-radius: 0;
  }

  100% {
    transform: translateY(-1000px) rotate(720deg);
    opacity: 0;
    border-radius: 50%;
  }
}

    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }

    h1 {
      color: #333;
      text-align: center;
      font-size: 24px;
    }

    h2 {
      color: #666;
      font-size: 18px;
      margin-bottom: 10px;
      opacity: 0;
      transition: opacity 0.5s ease-in;
    }

    ul {
      list-style-type: none;
      padding: 0;
      margin-left: 20px;
    }

    li {
      margin-bottom: 5px;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.5s ease-in;
    }
  </style>
  <script>
    window.addEventListener('scroll', function() {
      var fadeInElements = document.querySelectorAll('h2, li');
      for (var i = 0; i < fadeInElements.length; i++) {
        var element = fadeInElements[i];
        var positionFromTop = element.getBoundingClientRect().top;
        var windowHeight = window.innerHeight;
        if (positionFromTop - windowHeight <= 0) {
          element.style.opacity = 1;
        }
      }
    });
  </script>
</head>
<body>
 
  <nav class="navbar navbar-expand-lg bg-body-tertiary">
  <div class="container-fluid">
    <a class="navbar-brand" href="#">OS Lab</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link active" aria-current="page" href="mainhome.html">Home</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="#">About</a>
        </li>
      
      </ul>
    </div>
  </div>
</nav>


 <h1>Documentation</h1>

  <div class="container">
      <ul class="circles">
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
      </ul>
    </div>


  <h2>CPU Scheduling</h2>
  <ul>
    <li>ROUND ROBIN - It is a scheduling algorithm commonly used in computer systems and operating systems to manage the execution of processes or tasks. It is designed to provide fairness and ensure that each process gets an equal amount of CPU time.</li>
    <li>SHORTEST JOB FIRST - It is a non-preemptive scheduling algorithm used in computer systems and operating systems to prioritize processes based on their execution time. It aims to minimize the average waiting time or turnaround time by giving priority to the process with the shortest burst time.</li>
    <li>PRIORITY SCHEDULING - Priority scheduling is a scheduling algorithm used in computer systems and operating systems to prioritize processes based on their priority levels. Each process is assigned a priority value, and the scheduler selects the process with the highest priority for execution.</li>
    <li>FCFS - FCFS, or First-Come-First-Served, is a simple and straightforward scheduling algorithm used in computer systems and operating systems. In FCFS scheduling, processes are executed in the order they arrive or are submitted to the system.</li>
  </ul>

  <h2>IPC</h2>
  <ul>
    <li>MESSAGE PASSING THROUGH KERNEL - Message passing through the kernel refers to a communication mechanism in computer systems where processes or threads exchange information by sending messages through the operating system kernel. The kernel acts as an intermediary, facilitating the transmission of messages between different processes or threads.</li>
    <li>Read/ write from shared memory in RAM - Reading from and writing to shared memory in RAM is a mechanism used for interprocess communication (IPC) in computer systems. Shared memory allows multiple processes or threads to access and modify a common region of memory, enabling efficient and fast data sharing.</li>
  </ul>

  <h2>Process Synchronization</h2>
  <ul>
    <li>DINING PHILOSOPHERS PROBLEM - The Dining Philosophers problem is a classic synchronization problem in computer science that illustrates challenges in resource allocation and concurrency control. It was proposed by Edsger Dijkstra in 1965.</li>
    <li>READER - WRITER'S PROBLEM - The Reader-Writer's problem is a classic synchronization problem in computer science that involves coordinating access to a shared resource between multiple readers and writers. The problem highlights the challenges of ensuring concurrent access while maintaining data consistency and fairness.</li>
    <li>PRODUCER CONSUMER PROBLEM - The Producer-Consumer problem is a classic synchronization problem in computer science that involves coordinating the interaction between two types of processes, known as producers and consumers, who share a common buffer or queue.</li>
  </ul>

  <h2>Deadlock</h2>
  <ul>
    <li>DEADLOCK DETECTION - Deadlock detection is a technique used in computer systems to identify the presence of deadlocks, which occur when two or more processes are waiting for each other to release resources, resulting in a circular dependency and an inability to proceed.</li>
    <li>BANKER'S ALGORITHM - The Banker's algorithm is a resource allocation and deadlock avoidance algorithm used in operating systems. It is designed to prevent deadlocks by ensuring that the available resources can be allocated safely to processes.</li>
    <li>RESOURCE ALLOCATION GRAPH (RAG) - A resource allocation graph is a graphical representation used in the analysis and visualization of resource allocation and deadlock detection in operating systems. It helps to understand the relationships between processes and the resources they require and hold.</li>
  </ul>

  <h2>Threading</h2>
  <ul>
    <li>USING MUTEX - Threading using mutex, short for mutual exclusion, is a technique used to ensure thread safety and prevent data races in concurrent programming. Mutex is a synchronization primitive that provides exclusive access to a shared resource, allowing only one thread to access the resource at a time.</li>
    <li>USING SEMAPHORE - Threading using semaphores is a technique used in concurrent programming to control access to shared resources and synchronize the execution of multiple threads. A semaphore is a synchronization primitive that manages a count and supports two main operations: "wait" (P) and "signal" (V).</li>
  </ul>

  <h2>Memory Management</h2>
  <ul>
    <li>MVT - MVT, or Multiprogramming with Variable Tasks, is a memory management technique used in operating systems to allocate memory to multiple tasks or processes dynamically. MVT is an extension of the MVT technique, which stands for Multiprogramming with Fixed Tasks.</li>
    <li>MFT - MFT, or Multiprogramming with Fixed Tasks, is a memory management technique used in operating systems to allocate memory to multiple tasks or processes. It is based on the concept of dividing the available memory into fixed-size partitions, with each partition allocated to a specific task.</li>
  </ul>

  <h2>Memory Segment/Block Allocation</h2>
  <ul>
    <li>WORST-FIT - Worst-fit is a memory allocation algorithm used in computer systems to allocate memory to processes or tasks. It is one of several strategies employed to manage memory efficiently.</li>
    <li>BEST-FIT - Best-fit is a memory allocation algorithm used in computer systems to assign memory blocks to processes or tasks efficiently. It is one of the strategies employed to manage memory effectively.</li>
    <li>FIRST-FIT - First-fit is a memory allocation algorithm used in computer systems to assign memory blocks to processes or tasks. It is one of the commonly employed strategies for efficient memory management.</li>
  </ul>

  <h2>Paging</h2>
  <ul>
    <li>CREATING PAGE TABLE AND GET PHYSICAL ADDRESS FROM LOGICAL ADDRESS FOR APPROPRIATE PAGE SIZE - Creating a page table and translating logical addresses to physical addresses is an essential process in virtual memory management. The page table is a data structure used by the operating system to map logical addresses, which are generated by the CPU, to physical addresses in the main memory.</li>
  </ul>

  <h2>Page Replacement</h2>
  <ul>
    <li>FIFO - FIFO (First-In-First-Out) is a basic scheduling and data management algorithm used in various domains, including operating systems, networking, and storage.</li>
    <li>OPTIMAL - The Optimal algorithm is an optimal page replacement algorithm used in the context of virtual memory management to determine which page should be evicted from memory when a page fault occurs. It is often used as a benchmark for evaluating other page replacement algorithms.</li>
    <li>LRU - LRU (Least Recently Used) is a popular page replacement algorithm used in computer systems and operating systems to manage memory efficiently. It aims to minimize page faults by evicting the least recently used page from memory when a page fault occurs.</li>
  </ul>



<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.7/dist/umd/popper.min.js" integrity="sha384-zYPOMqeu1DAVkHiLqWBUTcbYfZ8osu1Nd6Z89ify25QV9guujx43ITvfi12/QExE" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.min.js" integrity="sha384-Y4oOpwW3duJdCWv5ly8SCFYWqFDsfob/3GkgExXKV4idmbt98QcxXYs9UoXAB7BZ" crossorigin="anonymous"></script>
 

</body>
</html>
